#!KAMAILIO
#
# Somleng CPaaS - Kamailio SIP Router Configuration
# High-volume, production-ready SBC and SIP routing
#

####### Global Parameters #########

# Enable debugging
debug=2
log_stderror=no
log_facility=LOG_LOCAL0

# Number of worker processes
children=8

# Memory settings
shm_mem=256
pkg_mem=8

# Network settings
port=5060
tls_port_no=5061

# Listen interfaces
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=tls:0.0.0.0:5061

# Aliases
alias="SOMLENG_DOMAIN"

# Enable TCP
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605

# TLS settings
enable_tls=yes
tls_method=TLSv1.2+
tls_verify_server=0
tls_verify_client=0
tls_require_client_certificate=0

####### Modules Section ########

# Core modules
loadmodule "tm.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "mi_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"

# Database modules
loadmodule "db_postgres.so"
loadmodule "sqlops.so"

# Authentication modules
loadmodule "auth.so"
loadmodule "auth_db.so"

# NAT traversal modules
loadmodule "nathelper.so"
loadmodule "rtpengine.so"

# Load balancing modules
loadmodule "dispatcher.so"

# Dialog module for session tracking
loadmodule "dialog.so"

# Pike module for flood protection
loadmodule "pike.so"

# Permissions module
loadmodule "permissions.so"

# Statistics modules
loadmodule "statistics.so"
loadmodule "kex.so"

# TLS module
loadmodule "tls.so"

# JSON and HTTP modules
loadmodule "json.so"
loadmodule "http_client.so"

####### Module Parameters #########

# ----- tm params -----
modparam("tm", "fr_timer", 5)
modparam("tm", "fr_inv_timer", 30)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

# ----- rr params -----
modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)

# ----- usrloc params -----
modparam("usrloc", "db_url", "KAMAILIO_DB_URL")
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)

# ----- auth_db params -----
modparam("auth_db", "db_url", "KAMAILIO_DB_URL")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@SOMLENG_DOMAIN")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

# ----- dispatcher params -----
modparam("dispatcher", "db_url", "KAMAILIO_DB_URL")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(dsdst)")
modparam("dispatcher", "grp_avp", "$avp(dsgrp)")
modparam("dispatcher", "cnt_avp", "$avp(dscnt)")
modparam("dispatcher", "sock_avp", "$avp(dssock)")

# ----- dialog params -----
modparam("dialog", "dlg_flag", FLT_DLG)
modparam("dialog", "profiles_with_value", "caller")

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", "KAMAILIO_DB_URL")

####### Routing Logic ########

# Define flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_DLG 4
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

# Main request routing logic
request_route {
    # Per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    ### only initial requests (no To tag)

    # Record routing for dialog forming requests (in case they are routed)
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(FLT_ACC); # do accounting
        setflag(FLT_DLG); # enable dialog tracking
    }

    # Handle registrations
    route(REGISTRAR);

    if ($rU==$null) {
        # Request with no Username in RURI
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # Route to FreeSWITCH
    route(FREESWITCH);
}

# Wrapper for relaying requests
route[RELAY] {
    # Enable additional event routes for forwarded requests
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per SIP request initial checks
route[REQINIT] {
    # Flood detection from same IP and traffic ban for a while
    if (!pike_check_req()) {
        xlog("L_ALERT", "ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        exit;
    }

    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
        # Silent drop for scanners
        exit;
    }

    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # Sequential request within a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(FLT_ACC); # do accounting ...
            setflag(FLT_ACCFAILED); # ... even if the transaction fails
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            route(NATMANAGE);
        } else if ( is_method("NOTIFY") ) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if ( t_check_trans() ) {
            # No loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}

# Handle SIP registrations
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;

    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        # Uncomment this to allow path insertion
        # setbflag(FLB_NATSIPPING);
    }

    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# Route to FreeSWITCH servers
route[FREESWITCH] {
    # Load balance between FreeSWITCH nodes
    if(!ds_select_dst("1", "4")) {
        send_reply("404", "No destination available");
        exit;
    }

    xlog("L_DBG", "--- FREESWITCH: routing call to $du\n");
    route(RELAY);
    exit;
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(FLT_NATS);
    }
    return;
}

# RTPEngine NAT handling
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
        }
    }
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(FLB_NATB)) {
            set_contact_alias();
        }
    }

    if (is_method("INVITE|UPDATE")) {
        rtpengine_offer();
    } else if (is_method("ACK")) {
        rtpengine_answer();
    } else if (is_method("BYE|CANCEL")) {
        rtpengine_delete();
    }

    return;
}

# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
    return;
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xdbg("incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
    return;
}

# Manage failure routing
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;

    # Next destination - only for 500 or local timeout
    if (t_check_status("500") or (t_branch_timeout() and !t_branch_replied())) {
        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE");
            route(RELAY);
            exit;
        }
    }
}

####### RPC Control Interface ########
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

####### MI Commands ########
# Enable MI commands over RPC
modparam("mi_rpc", "rpc_url", "tcp:0.0.0.0:9060")